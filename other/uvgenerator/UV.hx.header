/*
 * Copyright (C)2005-2019 Haxe Foundation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

// This file is automatically generated by a tool in Hashlink repo.
// see <hashlink_repo>/other/uvgenerator

// Contents of <hashlink_repo>/other/uvgenerator/UV.hx.header :

package hl.uv;

import hl.uv.Handle;
import hl.uv.Request;
import hl.uv.SockAddr;
import hl.uv.Dns;
import hl.uv.Dir;
import hl.uv.Loop;
import hl.uv.File;
import hl.uv.Tty;
import hl.uv.Udp;
import hl.uv.Process;
import hl.uv.Signal;

typedef UvUidT = Int;
typedef UvGidT = Int;
typedef UvPidT = Int;
typedef UvHandleType = HandleType;
typedef UvReqType = RequestType;
typedef UvRunMode = LoopRunMode;
typedef UvFsType = FsRequestType;
typedef UvTtyModeT = TtyMode;
typedef UvTtyVtermstateT = TtyVTermState;
typedef UvTtyVtermstateTStar = Ref<TtyVTermState>;
typedef UvMembership = UdpMembership;

abstract UvFile(Int) {
	@:allow(hl.uv) inline function new(fd:Int) this = fd;
}

abstract UvUdpSendTStar(UvReqTStar) to UvReqTStar {}
abstract UvWriteTStar(UvReqTStar) to UvReqTStar {}
abstract UvShutdownTStar(UvReqTStar) to UvReqTStar {}
abstract UvRandomTStar(UvReqTStar) to UvReqTStar {}
abstract UvGetnameinfoTStar(UvReqTStar) to UvReqTStar {}
abstract UvGetaddrinfoTStar(UvReqTStar) to UvReqTStar {}
abstract UvFsTStar(UvReqTStar) to UvReqTStar {}
abstract UvConnectTStar(UvReqTStar) to UvReqTStar {}

abstract UvUdpTStar(UvHandleTStar) to UvHandleTStar {}
abstract UvStreamTStar(UvHandleTStar) to UvHandleTStar {}
abstract UvTtyTStar(UvStreamTStar) to UvStreamTStar to UvHandleTStar {}
abstract UvTcpTStar(UvStreamTStar) to UvStreamTStar to UvHandleTStar {}
abstract UvPipeTStar(UvStreamTStar) to UvStreamTStar to UvHandleTStar {}
abstract UvTimerTStar(UvHandleTStar) to UvHandleTStar {}
abstract UvSignalTStar(UvHandleTStar) to UvHandleTStar {}
abstract UvProcessTStar(UvHandleTStar) to UvHandleTStar {}
abstract UvPrepareTStar(UvHandleTStar) to UvHandleTStar {}
abstract UvIdleTStar(UvHandleTStar) to UvHandleTStar {}
abstract UvFsPollTStar(UvHandleTStar) to UvHandleTStar {}
abstract UvFsEventTStar(UvHandleTStar) to UvHandleTStar {}
abstract UvCheckTStar(UvHandleTStar) to UvHandleTStar {}
abstract UvAsyncTStar(UvHandleTStar) to UvHandleTStar {}

abstract UvBufTArr(Abstract<"uv_buf_t_arr">) {}
abstract CSockaddrStorageStar(Abstract<"sockaddr_storage_star">) {}
abstract UvStdioContainerTStar(Abstract<"uv_stdio_container_t_star">) {}

//TODO: implement these
private typedef UInt = Int;
private typedef U64 = I64;

/**
	Automatically generated bindings for libuv.
	Avoid using this module directly.
	BACKWARD COMPATIBILITY OF THIS MODULE IS NOT MAINTAINED.
**/
@:hlNative("uv")
extern class UV {
	extern static public inline function resolve(result:Int):Int {
		if(result < 0)
			throw new UVException(translate_uv_error(result));
		return result;
	}

	extern static public inline function throwErr(result:Int):Int {
		throw new UVException(translate_uv_error(result));
	}

	extern static public inline function checkLoop(loop:Loop):Void {
		if(loop == null)
			throw new UVException(UV_EINVAL);
	}

	extern static public inline function toUTF8(s:String):Bytes {
		return @:privateAccess s.toUtf8();
	}

	extern static public inline function fromUTF8(b:Bytes):String {
		return @:privateAccess String.fromUTF8(b);
	}

	static public function alloc_char_array(length:Int):Ref<Bytes>;
	static public function free_char_array(a:Ref<Bytes>):Void;
	static public function free_bytes(bytes:Bytes):Void;
	static public function translate_uv_error(uvErrno:Int):UVError;
	static public function translate_to_uv_error(errno:Int):Int;
	static public function translate_sys_signal(sigNum:Int):SigNum;
	static public function translate_to_sys_signal(sigNum:SigNum):Int;
	static public function free_handle(data:UvHandleTStar):Void;
	static public function handle_set_data_with_gc<T:UvHandleTStar>(handle:UvHandleTStar, data:Handle<T>):Void;
	static public function req_set_data_with_gc<T:UvReqTStar>(req:UvReqTStar, data:Request<T>):Void;
	static public function free_req(req:UvReqTStar):Void;
	static public function alloc_loop():UvLoopTStar;
	static public function free_loop(req:UvLoopTStar):Void;
	static public function alloc_async():UvAsyncTStar;
	static public function alloc_timer():UvTimerTStar;
	static public function alloc_check():UvCheckTStar;
	static public function alloc_tcp():UvTcpTStar;
	static public function alloc_sockaddr_storage():CSockaddrStorageStar;
	static public function sockaddr_storage_size():Int;
	static public function free_sockaddr_storage(addr:CSockaddrStorageStar):Void;
	static public function sockaddr_of_storage(addr:CSockaddrStorageStar):CSockaddrStar;
	static public function sockaddr_to_storage(addr:CSockaddrStar):CSockaddrStorageStar;
	static public function alloc_udp():UvUdpTStar;
	static public function alloc_udp_send():UvUdpSendTStar;
	static public function alloc_pipe():UvPipeTStar;
	static public function alloc_stdio_container(stdio:NativeArray<Dynamic>, count:Int):UvStdioContainerTStar; //Dynamic should contain hl.uv.Process.ProcessStdio instances
	static public function free_stdio_container(stdio:UvStdioContainerTStar):Void;
	static public function alloc_process_options(file:Bytes, args:Ref<Bytes>, env:Ref<Bytes>, cwd:Bytes, flags:Int, stdio_count:Int, stdio:UvStdioContainerTStar, uid:UvUidT, gid:UvGidT):UvProcessOptionsTStar;
	static public function free_process_options(options:UvProcessOptionsTStar):Void;
	static public function alloc_process():UvProcessTStar;
	static public function alloc_getaddrinfo():UvGetaddrinfoTStar;
	static public function alloc_getnameinfo():UvGetnameinfoTStar;
	static public function alloc_addrinfo(flags:Int, family:AddressFamily, socktype:SocketType, protocol:Int):CAddrinfoStar;
	static public function alloc_shutdown():UvShutdownTStar;
	static public function alloc_write():UvWriteTStar;
	static public function alloc_connect():UvConnectTStar;
	static public function address_family_to_af(family:AddressFamily):Int;
	static public function address_family_to_pf(family:AddressFamily):Int;
	static public function addrinfo_ai_family(ai:CAddrinfoStar):AddressFamily;
	static public function addrinfo_ai_socktype(ai:CAddrinfoStar):SocketType;
	static public function addrinfo_ai_protocol(ai:CAddrinfoStar):Int;
	static public function addrinfo_ai_addr(ai:CAddrinfoStar):SockAddr;
	static public function addrinfo_ai_canonname(ai:CAddrinfoStar):Bytes;
	static public function addrinfo_ai_next(ai:CAddrinfoStar):Null<CAddrinfoStar>;
	static public function nameinfo_flags_to_native(ai:NameInfoFlags):Int;
	static public function alloc_fs():UvFsTStar;
	static public function pointer_to_dir(req:Pointer):UvDirTStar;
	static public function free_dir(dirent:UvDirTStar):Void;
	static public function dir_init(dir:UvDirTStar, num_entries:Int):Void;
	static public function dir_nentries(dir:UvDirTStar):Int;
	static public function dir_dirent(dir:UvDirTStar, index:Int):UvDirentTStar;
	static public function free_dirent(dirent:UvDirentTStar):Void;
	static public function dirent_name(dirent:UvDirentTStar):Bytes;
	static public function dirent_type(dirent:UvDirentTStar):DirEntryType;
	static public function free_buf(buf:UvBufTArr):Void;
	static public function alloc_buf(bytes:Bytes, bytesLength:Int):UvBufTArr;
	static public function buf_set(buf:UvBufTArr, base:Bytes, length:Int):Void;
	static public function buf_base(buf:UvBufTArr):Bytes;
	static public function buf_len(buf:UvBufTArr):U64;
	static public function alloc_tty():UvTtyTStar;

// Auto generated content :

